---
title: Rejestrowanie i przechwytuje operacji bazy danych — EF6
author: divega
ms.date: 2016-10-23
ms.prod: entity-framework
ms.author: divega
ms.manager: avickers
ms.technology: entity-framework-6
ms.topic: article
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
caps.latest.revision: 3
ms.openlocfilehash: 1d0e953309f3c81a2941d6850e169aaa31ae8de0
ms.sourcegitcommit: bdd06c9a591ba5e6d6a3ec046c80de98f598f3f3
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/10/2018
ms.locfileid: "37949286"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="08b1a-102">Rejestrowanie i przechwytuje operacji bazy danych</span><span class="sxs-lookup"><span data-stu-id="08b1a-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="08b1a-103">**EF6 począwszy tylko** — funkcje, interfejsów API itp. z opisem na tej stronie zostały wprowadzone w programie Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="08b1a-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="08b1a-104">Jeśli używasz starszej wersji, niektóre lub wszystkie informacje, nie ma zastosowania.</span><span class="sxs-lookup"><span data-stu-id="08b1a-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="08b1a-105">Począwszy od platformy Entity Framework 6, w dowolnym momencie Entity Framework wysyła polecenie do bazy danych to polecenie może zostać przechwycona przez kod aplikacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="08b1a-106">Najczęściej jest używana do logowania SQL, ale może również służyć do modyfikowania lub Przerwij polecenie.</span><span class="sxs-lookup"><span data-stu-id="08b1a-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="08b1a-107">W szczególności EF obejmuje:</span><span class="sxs-lookup"><span data-stu-id="08b1a-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="08b1a-108">Właściwości rejestrowania w kontekście podobnie jak DataContext.Log w składniku LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="08b1a-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="08b1a-109">Mechanizm, aby dostosować zawartość i formatowania danych wyjściowych wysyłane do dziennika</span><span class="sxs-lookup"><span data-stu-id="08b1a-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="08b1a-110">Niskiego poziomu bloków konstrukcyjnych dla przejmowanie, dzięki czemu większa kontrola/elastycznie</span><span class="sxs-lookup"><span data-stu-id="08b1a-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="08b1a-111">Właściwości rejestrowania w kontekście</span><span class="sxs-lookup"><span data-stu-id="08b1a-111">Context Log property</span></span>  

<span data-ttu-id="08b1a-112">Można ustawić właściwości DbContext.Database.Log delegata dla dowolnej metody, która przyjmuje ciąg.</span><span class="sxs-lookup"><span data-stu-id="08b1a-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="08b1a-113">Najczęściej jest używany z dowolnym TextWriter, ustawiając jej do metody "Zapisywanie" tego TextWriter.</span><span class="sxs-lookup"><span data-stu-id="08b1a-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="08b1a-114">Moduł zapisujący zostaną zarejestrowane SQL wszystkich generowanych przez bieżącego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="08b1a-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="08b1a-115">Na przykład poniższy kod zostanie dziennika SQL do konsoli:</span><span class="sxs-lookup"><span data-stu-id="08b1a-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="08b1a-116">Należy zauważyć, że kontekst. Console.Write — ustawiono Database.Log.</span><span class="sxs-lookup"><span data-stu-id="08b1a-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="08b1a-117">To wszystko, co jest potrzebne do logowania SQL do konsoli.</span><span class="sxs-lookup"><span data-stu-id="08b1a-117">This is all that is needed to log SQL to the console.</span></span>  

### <a name="example-output"></a><span data-ttu-id="08b1a-118">Przykładowe dane wyjściowe</span><span class="sxs-lookup"><span data-stu-id="08b1a-118">Example output</span></span>  

<span data-ttu-id="08b1a-119">Dodajmy kilka prostych kodów zapytania/insert/update, dzięki czemu możemy zobaczyć pewne dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="08b1a-119">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="08b1a-120">Spowoduje to wygenerowanie następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="08b1a-120">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="08b1a-121">(Należy pamiętać, że to dane wyjściowe przy założeniu, że już stało się inicjowanie bazy danych.</span><span class="sxs-lookup"><span data-stu-id="08b1a-121">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="08b1a-122">Jeśli inicjowanie bazy danych nie ma już wystąpił, a następnie będzie można o wiele więcej danych wyjściowych, przedstawiający wszystkie prace migracje nie dzieje się w tle, aby sprawdzić lub Utwórz nową bazę danych.)</span><span class="sxs-lookup"><span data-stu-id="08b1a-122">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

### <a name="what-gets-logged"></a><span data-ttu-id="08b1a-123">Co pobiera zarejestrowane?</span><span class="sxs-lookup"><span data-stu-id="08b1a-123">What gets logged?</span></span>  

<span data-ttu-id="08b1a-124">Gdy właściwość dziennika ma wartość wszystkie poniższe będą rejestrowane:</span><span class="sxs-lookup"><span data-stu-id="08b1a-124">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="08b1a-125">SQL dla różnych rodzajów poleceń.</span><span class="sxs-lookup"><span data-stu-id="08b1a-125">SQL for all different kinds of commands.</span></span> <span data-ttu-id="08b1a-126">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="08b1a-126">For example:</span></span>  
    - <span data-ttu-id="08b1a-127">Zapytania, łącznie z normalnym zapytań LINQ, eSQL kwerend i pierwotne zapytania z metody takie jak SqlQuery</span><span class="sxs-lookup"><span data-stu-id="08b1a-127">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="08b1a-128">Operacje wstawiania, aktualizacji i usuwania, wygenerowane jako część SaveChanges</span><span class="sxs-lookup"><span data-stu-id="08b1a-128">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="08b1a-129">Podczas ładowania zapytania, np. tych generowanych przez powolne ładowanie relacji</span><span class="sxs-lookup"><span data-stu-id="08b1a-129">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="08b1a-130">Parametry</span><span class="sxs-lookup"><span data-stu-id="08b1a-130">Parameters</span></span>  
- <span data-ttu-id="08b1a-131">Określa, czy polecenie jest wykonywane asynchronicznie</span><span class="sxs-lookup"><span data-stu-id="08b1a-131">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="08b1a-132">Sygnatura czasowa wskazująca, podczas uruchamiania polecenia wykonywania</span><span class="sxs-lookup"><span data-stu-id="08b1a-132">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="08b1a-133">Czy polecenie zostało wykonane pomyślnie, nie powiodło się, zgłaszając wyjątek lub asynchroniczne, zostało anulowane</span><span class="sxs-lookup"><span data-stu-id="08b1a-133">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="08b1a-134">Niektóre wskazania wartość wyniku</span><span class="sxs-lookup"><span data-stu-id="08b1a-134">Some indication of the result value</span></span>  
- <span data-ttu-id="08b1a-135">Kwota przybliżony czas potrzebny do wykonania polecenia.</span><span class="sxs-lookup"><span data-stu-id="08b1a-135">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="08b1a-136">Należy pamiętać, że jest to czas wysyłanie polecenia do pobierania obiektu wyników, ponownie.</span><span class="sxs-lookup"><span data-stu-id="08b1a-136">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="08b1a-137">Nie ma czasu można odczytać wyników.</span><span class="sxs-lookup"><span data-stu-id="08b1a-137">It does not include time to read the results.</span></span>  

<span data-ttu-id="08b1a-138">Patrząc powyższych danych wyjściowych przykładu, każdy z czterech poleceń rejestrowane są:</span><span class="sxs-lookup"><span data-stu-id="08b1a-138">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="08b1a-139">Zapytanie wynikające z wywołania do kontekstu. Blogs.First</span><span class="sxs-lookup"><span data-stu-id="08b1a-139">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="08b1a-140">Należy zauważyć, że metoda ToString pobierania SQL nie będzie działać dla tego zapytania, ponieważ "First" nie zawiera element IQueryable, na którym może być wywoływana ToString</span><span class="sxs-lookup"><span data-stu-id="08b1a-140">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="08b1a-141">Zapytanie wynikające z powolne ładowanie blogu. Wpisy</span><span class="sxs-lookup"><span data-stu-id="08b1a-141">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="08b1a-142">Zwróć uwagę, dzieje się szczegóły parametrów dla wartości klucza, dla którego opóźnieniem ładowania</span><span class="sxs-lookup"><span data-stu-id="08b1a-142">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="08b1a-143">Rejestrowane są tylko te właściwości parametru, które są ustawione na wartości innych niż domyślne.</span><span class="sxs-lookup"><span data-stu-id="08b1a-143">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="08b1a-144">Na przykład właściwość rozmiaru jest wyświetlana tylko jeśli jest różna od zera.</span><span class="sxs-lookup"><span data-stu-id="08b1a-144">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="08b1a-145">Dwa polecenia wynikające z SaveChangesAsync; jeden dla aktualizacji zmienić tytuł wpisu, drugie dla instrukcji insert dodać nowy wpis</span><span class="sxs-lookup"><span data-stu-id="08b1a-145">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="08b1a-146">Zwróć uwagę, szczegóły parametrów właściwości klucza Obcego i tytuł</span><span class="sxs-lookup"><span data-stu-id="08b1a-146">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="08b1a-147">Należy zauważyć, że te polecenia są wykonywane asynchronicznie</span><span class="sxs-lookup"><span data-stu-id="08b1a-147">Notice that these commands are being executed asynchronously</span></span>  

### <a name="logging-to-different-places"></a><span data-ttu-id="08b1a-148">Rejestrowanie w różnych miejscach</span><span class="sxs-lookup"><span data-stu-id="08b1a-148">Logging to different places</span></span>  

<span data-ttu-id="08b1a-149">Jak wspomniano powyżej logowanie do konsoli jest bardzo proste.</span><span class="sxs-lookup"><span data-stu-id="08b1a-149">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="08b1a-150">Jest również łatwe logowanie do pamięci, plików, itp. przy użyciu różnych rodzajów z [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="08b1a-150">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="08b1a-151">Jeśli znasz za pomocą LINQ to SQL, można zauważyć, że w składniku LINQ to SQL ustawiono właściwość dziennika do rzeczywistego TextWriter obiektu (na przykład Console.Out) podczas w programie EF ustawiono właściwość dziennika do metody, która akceptuje ciąg (na przykład Console.Write — lub Console.Out.Write).</span><span class="sxs-lookup"><span data-stu-id="08b1a-151">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="08b1a-152">Przyczyną jest oddzielenie EF z TextWriter, akceptując dowolnym delegatem, który może działać jako obiekt sink dla ciągów.</span><span class="sxs-lookup"><span data-stu-id="08b1a-152">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="08b1a-153">Załóżmy, że masz już pewne struktury rejestrowania i definiuje metodę rejestrowania w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="08b1a-153">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="08b1a-154">To może podłączany do właściwości rejestrowania EF następująco:</span><span class="sxs-lookup"><span data-stu-id="08b1a-154">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

### <a name="result-logging"></a><span data-ttu-id="08b1a-155">Rejestrowanie wyników</span><span class="sxs-lookup"><span data-stu-id="08b1a-155">Result logging</span></span>  

<span data-ttu-id="08b1a-156">Rejestrator domyślny tekst polecenia (SQL), parametry i dzienników wiersza "Executing" z sygnaturą czasową przed wysłaniem polecenia do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="08b1a-156">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="08b1a-157">"Ukończone" wiersz zawierający czas, który upłynął są rejestrowane następujące wykonanie polecenia.</span><span class="sxs-lookup"><span data-stu-id="08b1a-157">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="08b1a-158">Należy pamiętać, że asynchroniczne "ukończony" wiersz polecenia nie jest rejestrowane, dopóki zadanie asynchroniczne faktycznie kończy, kończy się niepowodzeniem lub zostanie anulowane.</span><span class="sxs-lookup"><span data-stu-id="08b1a-158">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="08b1a-159">"Ukończone" wiersz zawiera różne informacje w zależności od typu polecenia i określa, czy wykonywanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="08b1a-159">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

#### <a name="successful-execution"></a><span data-ttu-id="08b1a-160">Pomyślne wykonanie</span><span class="sxs-lookup"><span data-stu-id="08b1a-160">Successful execution</span></span>  

<span data-ttu-id="08b1a-161">W przypadku poleceń, które się to odbyć danych wyjściowych jest "wykonane w x ms z wynikiem:" następuje niektóre wskazania wynik był.</span><span class="sxs-lookup"><span data-stu-id="08b1a-161">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="08b1a-162">Dla poleceń, które zwracają wynik czytnik danych oznaczenie jest typ [obiekt DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) zwracane.</span><span class="sxs-lookup"><span data-stu-id="08b1a-162">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="08b1a-163">Dla poleceń, które zwracają wartość całkowitą, takich jak aktualizacja przedstawionego powyżej wyniku, przedstawione polecenia jest tym liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="08b1a-163">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

#### <a name="failed-execution"></a><span data-ttu-id="08b1a-164">Wykonywanie nie powiodło się</span><span class="sxs-lookup"><span data-stu-id="08b1a-164">Failed execution</span></span>  

<span data-ttu-id="08b1a-165">Pomijanie wykonania</span><span class="sxs-lookup"><span data-stu-id="08b1a-165">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="08b1a-166">Jeśli ta opcja interceptor ustawia właściwości wyniku, zanim to polecenie zostało wykonane (w jednym z... Wykonywanie metod) następnie EF nie podejmie próby rzeczywistego wykonania polecenia, ale zamiast tego użyje po prostu zestaw wyników.</span><span class="sxs-lookup"><span data-stu-id="08b1a-166">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

#### <a name="canceled-execution"></a><span data-ttu-id="08b1a-167">Innymi słowy interceptor można pominąć wykonywanie polecenia, ale ma EF kontynuowane tak, jakby było zostały wykonane polecenie.</span><span class="sxs-lookup"><span data-stu-id="08b1a-167">Canceled execution</span></span>  

<span data-ttu-id="08b1a-168">Przykład sposobu użycia tego może być jest polecenia przetwarzania wsadowego, która była tradycyjnie wykonywana przy użyciu dostawcy zawijania.</span><span class="sxs-lookup"><span data-stu-id="08b1a-168">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="08b1a-169">Interceptor będzie przechowywać polecenia do późniejszego wykonania jako zadania wsadowego, ale będzie "poudawać" do programu EF, że polecenie było wykonywane w zwykły.</span><span class="sxs-lookup"><span data-stu-id="08b1a-169">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="08b1a-170">Należy pamiętać, że wymaga więcej niż to do zaimplementowania przetwarzania wsadowego, ale jest to przykład jak zmiana wyniku przejmowanie mogą być używane.</span><span class="sxs-lookup"><span data-stu-id="08b1a-170">Changing log content and formatting</span></span>  

### <a name="databaselogformatter"></a><span data-ttu-id="08b1a-171">Wykonanie również można pominąć, ustawiając właściwość wyjątku w jednej z... Wykonywanie metod.</span><span class="sxs-lookup"><span data-stu-id="08b1a-171">DatabaseLogFormatter</span></span>  

<span data-ttu-id="08b1a-172">Powoduje to EF kontynuować, tak, jakby wykonanie operacji miał nie powiodło się, zwracając dany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-172">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="08b1a-173">Oczywiście, może to spowodować aplikacji awarię, ale może to być także wyjątek przejściowy lub innych wyjątków, który jest obsługiwany przez EF.</span><span class="sxs-lookup"><span data-stu-id="08b1a-173">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="08b1a-174">Na przykład to może służyć w środowiskach testowych do testowania zachowanie aplikacji, gdy wykonywanie polecenia nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="08b1a-174">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="08b1a-175">Zmiana wyniku Po wykonaniu</span><span class="sxs-lookup"><span data-stu-id="08b1a-175">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="08b1a-176">Jeśli ta opcja ustawia interceptor właściwości wyniku Po wykonaniu polecenia (w jednym z... Wykonania metody), a następnie platforma EF użyje wynik zmieniono zamiast wynik, który faktycznie został zwrócony przez operację.</span><span class="sxs-lookup"><span data-stu-id="08b1a-176">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="08b1a-177">Podobnie jeśli interceptor ustawia właściwość wyjątku po wykonaniu polecenia, następnie EF spowoduje zgłoszenie wyjątku zestaw tak, jakby operacji miał wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-177">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="08b1a-178">Interceptor można również ustawić właściwość wyjątku na wartość null, aby wskazać, że nie należy zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-178">The most common methods to override are:</span></span>  

- <span data-ttu-id="08b1a-179">Może to być przydatne, jeśli nie można wykonać operacji, ale interceptor chce EF, aby kontynuować, tak, jakby zakończyło się operacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-179">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="08b1a-180">Zwykle obejmuje to również ustawienie wynik tak, aby EF jakąś wartość wynik, aby pracować, jak długo.</span><span class="sxs-lookup"><span data-stu-id="08b1a-180">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="08b1a-181">OriginalResult i oryginalny wyjątek</span><span class="sxs-lookup"><span data-stu-id="08b1a-181">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="08b1a-182">Po wykonaniu operacji EF zostanie ustawiony wynik i OriginalResult właściwości, jeśli wykonanie nie zakończyła się niepowodzeniem lub właściwości wyjątku i oryginalny wyjątek, jeśli wykonanie nie powiodło się z powodu wyjątku.</span><span class="sxs-lookup"><span data-stu-id="08b1a-182">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="08b1a-183">Właściwości OriginalResult i oryginalny wyjątek są przeznaczone tylko do odczytu i ustawionych tylko przez EF po rzeczywistego wykonania operacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-183">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="08b1a-184">Te właściwości nie może ustawić interceptory.</span><span class="sxs-lookup"><span data-stu-id="08b1a-184">This can be done with two overrides:</span></span>  

- <span data-ttu-id="08b1a-185">Oznacza to, że wszelkie interceptor może rozróżnić wystąpi wyjątek lub wynik, która została ustawiona przez niektóre interceptor, w przeciwieństwie do rzeczywistego wyjątek lub wynik, który wystąpił podczas operacji został wykonany.</span><span class="sxs-lookup"><span data-stu-id="08b1a-185">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="08b1a-186">Rejestrowanie interceptory</span><span class="sxs-lookup"><span data-stu-id="08b1a-186">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="08b1a-187">Po utworzeniu klasy, która implementuje co najmniej jeden z interfejsów przejmowanie mogą być rejestrowane struktury jednostek przy użyciu klasy DbInterception.</span><span class="sxs-lookup"><span data-stu-id="08b1a-187">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="08b1a-188">Interceptory można zarejestrować w taki sposób, na poziomie domeny aplikacji przy użyciu mechanizmu DbConfiguration konfiguracja na podstawie kodu.</span><span class="sxs-lookup"><span data-stu-id="08b1a-188">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="08b1a-189">Przykład: Rejestrowanie NLog</span><span class="sxs-lookup"><span data-stu-id="08b1a-189">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="08b1a-190">Teraz umieść to wszystko ze sobą przykładowi, przy użyciu IDbCommandInterceptor i NLog do:</span><span class="sxs-lookup"><span data-stu-id="08b1a-190">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="08b1a-191">Ostrzeżenie dla dowolnego polecenia, który jest wykonywany bez asynchronicznie dziennika</span><span class="sxs-lookup"><span data-stu-id="08b1a-191">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="08b1a-192">Błąd dla dowolnego polecenia, który zgłasza wyjątek podczas wykonywania</span><span class="sxs-lookup"><span data-stu-id="08b1a-192">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="08b1a-193">Poniżej przedstawiono klasy, która wykonuje rejestrowanie, które powinny być rejestrowane, jak pokazano powyżej:</span><span class="sxs-lookup"><span data-stu-id="08b1a-193">This is done using code-based configuration.</span></span> <span data-ttu-id="08b1a-194">Zwróć uwagę, jak ten kod używa kontekstu przejmowanie, aby dowiedzieć się, gdy polecenie jest wykonywane innych niż asynchronicznie, a także do wykrywania, gdy wystąpił błąd podczas wykonywania polecenia.</span><span class="sxs-lookup"><span data-stu-id="08b1a-194">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="08b1a-195">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="08b1a-195">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="08b1a-196">Za pomocą nowego DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="08b1a-196">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="08b1a-197">Ten nowy DatabaseLogFormatter będzie używany w dowolnym momencie Database.Log jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="08b1a-197">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="08b1a-198">Tak uruchamiając kod z części 1 teraz spowoduje następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="08b1a-198">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="08b1a-199">Bloki konstrukcyjne przejmowanie</span><span class="sxs-lookup"><span data-stu-id="08b1a-199">Interception building blocks</span></span>  

<span data-ttu-id="08b1a-200">Do tej pory mają zobaczyliśmy, jak używać DbContext.Database.Log logowania SQL generowane przez EF.</span><span class="sxs-lookup"><span data-stu-id="08b1a-200">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="08b1a-201">Ale ten kod jest faktycznie fasada stosunkowo alokowania elastycznego za pośrednictwem niektórych niskiego poziomu bloków konstrukcyjnych dla bardziej ogólnych przejmowanie.</span><span class="sxs-lookup"><span data-stu-id="08b1a-201">But this code is actually a relatively thin façade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="08b1a-202">Przejmowanie interfejsów</span><span class="sxs-lookup"><span data-stu-id="08b1a-202">Interception interfaces</span></span>  

<span data-ttu-id="08b1a-203">Kod zatrzymania opiera się na koncepcji przejmowanie interfejsów.</span><span class="sxs-lookup"><span data-stu-id="08b1a-203">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="08b1a-204">Te interfejsy dziedziczyć IDbInterceptor i definiowania metod, które są wywoływane, gdy EF wykonuje jakąś akcję.</span><span class="sxs-lookup"><span data-stu-id="08b1a-204">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="08b1a-205">Celem jest zapewnienie jednego interfejsu na typ obiektu, które są przechwytywane.</span><span class="sxs-lookup"><span data-stu-id="08b1a-205">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="08b1a-206">Na przykład interfejs IDbCommandInterceptor definiuje metody, które są wywoływane przed EF wywołuje ExecuteNonQuery ExecuteScalar, ExecuteReader oraz powiązanych metod.</span><span class="sxs-lookup"><span data-stu-id="08b1a-206">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="08b1a-207">Podobnie interfejs definiuje metody, które są wywoływane po zakończeniu każdej z tych operacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-207">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="08b1a-208">Klasa DatabaseLogFormatter, która przyjrzeliśmy się powyżej implementuje ten interfejs logowania poleceń.</span><span class="sxs-lookup"><span data-stu-id="08b1a-208">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="08b1a-209">Kontekst przejmowanie</span><span class="sxs-lookup"><span data-stu-id="08b1a-209">The interception context</span></span>  

<span data-ttu-id="08b1a-210">Patrząc metod w interfejsach interceptor wobec jego okaże się, że każde wywołanie podanego obiektu typu DbInterceptionContext lub typu pochodzi od klasy to przykład DbCommandInterceptionContext\<\>.</span><span class="sxs-lookup"><span data-stu-id="08b1a-210">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="08b1a-211">Ten obiekt zawiera informacje kontekstowe o akcji, która zajmuje EF.</span><span class="sxs-lookup"><span data-stu-id="08b1a-211">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="08b1a-212">Na przykład jeśli akcja jest wykonywana w imieniu typu DbContext, kontekstu DbContext jest uwzględnione w DbInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="08b1a-212">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="08b1a-213">Podobnie do poleceń, które są wykonywane asynchronicznie, IsAsync flaga jest ustawiona na DbCommandInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="08b1a-213">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="08b1a-214">Obsługa wyników</span><span class="sxs-lookup"><span data-stu-id="08b1a-214">Result handling</span></span>  

<span data-ttu-id="08b1a-215">DbCommandInterceptionContext\< \> klasa zawiera właściwości o nazwie wynik, OriginalResult, wyjątków i oryginalny wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-215">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="08b1a-216">Te właściwości są ustawione na wartość null/zero dla wywołania metod przejmowanie, które są wywoływane przed wykonaniem operacji — czyli dla... Wykonywanie metod.</span><span class="sxs-lookup"><span data-stu-id="08b1a-216">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="08b1a-217">Jeśli operacja jest wykonywana, a zakończy się pomyślnie, następnie wynik i OriginalResult są ustawione na wynik operacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-217">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="08b1a-218">Następnie można zaobserwować te wartości w metodach przejmowanie, które są wywoływane po wykonaniu operacji — czyli na... Wykonane metody.</span><span class="sxs-lookup"><span data-stu-id="08b1a-218">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="08b1a-219">Podobnie jeśli operacja zgłosi, następnie właściwości wyjątku i oryginalny wyjątek zostaną ustawione.</span><span class="sxs-lookup"><span data-stu-id="08b1a-219">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="08b1a-220">Pomijanie wykonania</span><span class="sxs-lookup"><span data-stu-id="08b1a-220">Suppressing execution</span></span>  

<span data-ttu-id="08b1a-221">Jeśli ta opcja interceptor ustawia właściwości wyniku, zanim to polecenie zostało wykonane (w jednym z... Wykonywanie metod) następnie EF nie podejmie próby rzeczywistego wykonania polecenia, ale zamiast tego użyje po prostu zestaw wyników.</span><span class="sxs-lookup"><span data-stu-id="08b1a-221">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="08b1a-222">Innymi słowy interceptor można pominąć wykonywanie polecenia, ale ma EF kontynuowane tak, jakby było zostały wykonane polecenie.</span><span class="sxs-lookup"><span data-stu-id="08b1a-222">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="08b1a-223">Przykład sposobu użycia tego może być jest polecenia przetwarzania wsadowego, która była tradycyjnie wykonywana przy użyciu dostawcy zawijania.</span><span class="sxs-lookup"><span data-stu-id="08b1a-223">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="08b1a-224">Interceptor będzie przechowywać polecenia do późniejszego wykonania jako zadania wsadowego, ale będzie "poudawać" do programu EF, że polecenie było wykonywane w zwykły.</span><span class="sxs-lookup"><span data-stu-id="08b1a-224">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="08b1a-225">Należy pamiętać, że wymaga więcej niż to do zaimplementowania przetwarzania wsadowego, ale jest to przykład jak zmiana wyniku przejmowanie mogą być używane.</span><span class="sxs-lookup"><span data-stu-id="08b1a-225">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="08b1a-226">Wykonanie również można pominąć, ustawiając właściwość wyjątku w jednej z... Wykonywanie metod.</span><span class="sxs-lookup"><span data-stu-id="08b1a-226">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="08b1a-227">Powoduje to EF kontynuować, tak, jakby wykonanie operacji miał nie powiodło się, zwracając dany wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-227">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="08b1a-228">Oczywiście, może to spowodować aplikacji awarię, ale może to być także wyjątek przejściowy lub innych wyjątków, który jest obsługiwany przez EF.</span><span class="sxs-lookup"><span data-stu-id="08b1a-228">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="08b1a-229">Na przykład to może służyć w środowiskach testowych do testowania zachowanie aplikacji, gdy wykonywanie polecenia nie powiodło się.</span><span class="sxs-lookup"><span data-stu-id="08b1a-229">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="08b1a-230">Zmiana wyniku Po wykonaniu</span><span class="sxs-lookup"><span data-stu-id="08b1a-230">Changing the result after execution</span></span>  

<span data-ttu-id="08b1a-231">Jeśli ta opcja ustawia interceptor właściwości wyniku Po wykonaniu polecenia (w jednym z... Wykonania metody), a następnie platforma EF użyje wynik zmieniono zamiast wynik, który faktycznie został zwrócony przez operację.</span><span class="sxs-lookup"><span data-stu-id="08b1a-231">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="08b1a-232">Podobnie jeśli interceptor ustawia właściwość wyjątku po wykonaniu polecenia, następnie EF spowoduje zgłoszenie wyjątku zestaw tak, jakby operacji miał wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-232">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="08b1a-233">Interceptor można również ustawić właściwość wyjątku na wartość null, aby wskazać, że nie należy zgłosić wyjątek.</span><span class="sxs-lookup"><span data-stu-id="08b1a-233">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="08b1a-234">Może to być przydatne, jeśli nie można wykonać operacji, ale interceptor chce EF, aby kontynuować, tak, jakby zakończyło się operacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-234">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="08b1a-235">Zwykle obejmuje to również ustawienie wynik tak, aby EF jakąś wartość wynik, aby pracować, jak długo.</span><span class="sxs-lookup"><span data-stu-id="08b1a-235">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="08b1a-236">OriginalResult i oryginalny wyjątek</span><span class="sxs-lookup"><span data-stu-id="08b1a-236">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="08b1a-237">Po wykonaniu operacji EF zostanie ustawiony wynik i OriginalResult właściwości, jeśli wykonanie nie zakończyła się niepowodzeniem lub właściwości wyjątku i oryginalny wyjątek, jeśli wykonanie nie powiodło się z powodu wyjątku.</span><span class="sxs-lookup"><span data-stu-id="08b1a-237">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="08b1a-238">Właściwości OriginalResult i oryginalny wyjątek są przeznaczone tylko do odczytu i ustawionych tylko przez EF po rzeczywistego wykonania operacji.</span><span class="sxs-lookup"><span data-stu-id="08b1a-238">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="08b1a-239">Te właściwości nie może ustawić interceptory.</span><span class="sxs-lookup"><span data-stu-id="08b1a-239">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="08b1a-240">Oznacza to, że wszelkie interceptor może rozróżnić wystąpi wyjątek lub wynik, która została ustawiona przez niektóre interceptor, w przeciwieństwie do rzeczywistego wyjątek lub wynik, który wystąpił podczas operacji został wykonany.</span><span class="sxs-lookup"><span data-stu-id="08b1a-240">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="08b1a-241">Rejestrowanie interceptory</span><span class="sxs-lookup"><span data-stu-id="08b1a-241">Registering interceptors</span></span>  

<span data-ttu-id="08b1a-242">Po utworzeniu klasy, która implementuje co najmniej jeden z interfejsów przejmowanie mogą być rejestrowane struktury jednostek przy użyciu klasy DbInterception.</span><span class="sxs-lookup"><span data-stu-id="08b1a-242">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="08b1a-243">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="08b1a-243">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="08b1a-244">Interceptory można zarejestrować w taki sposób, na poziomie domeny aplikacji przy użyciu mechanizmu DbConfiguration konfiguracja na podstawie kodu.</span><span class="sxs-lookup"><span data-stu-id="08b1a-244">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="08b1a-245">Przykład: Rejestrowanie NLog</span><span class="sxs-lookup"><span data-stu-id="08b1a-245">Example: Logging to NLog</span></span>  

<span data-ttu-id="08b1a-246">Teraz umieść to wszystko ze sobą przykładowi, przy użyciu IDbCommandInterceptor i [NLog](http://nlog-project.org/) do:</span><span class="sxs-lookup"><span data-stu-id="08b1a-246">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="08b1a-247">Ostrzeżenie dla dowolnego polecenia, który jest wykonywany bez asynchronicznie dziennika</span><span class="sxs-lookup"><span data-stu-id="08b1a-247">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="08b1a-248">Błąd dla dowolnego polecenia, który zgłasza wyjątek podczas wykonywania</span><span class="sxs-lookup"><span data-stu-id="08b1a-248">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="08b1a-249">Poniżej przedstawiono klasy, która wykonuje rejestrowanie, które powinny być rejestrowane, jak pokazano powyżej:</span><span class="sxs-lookup"><span data-stu-id="08b1a-249">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="08b1a-250">Zwróć uwagę, jak ten kod używa kontekstu przejmowanie, aby dowiedzieć się, gdy polecenie jest wykonywane innych niż asynchronicznie, a także do wykrywania, gdy wystąpił błąd podczas wykonywania polecenia.</span><span class="sxs-lookup"><span data-stu-id="08b1a-250">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
